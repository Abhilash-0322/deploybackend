"""
Vulnerability Detection

Pattern-based vulnerability detection for Move smart contracts on Aptos.
Identifies common security issues in contract code and structure.
"""

from dataclasses import dataclass, field
from typing import Any, Optional
from enum import Enum

from app.core.contract_parser import ModuleInfo, FunctionSignature, FunctionVisibility


class VulnerabilitySeverity(str, Enum):
    """Severity levels for vulnerabilities."""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityType(str, Enum):
    """Types of vulnerabilities."""
    ACCESS_CONTROL = "access_control"
    REENTRANCY = "reentrancy"
    INTEGER_OVERFLOW = "integer_overflow"
    UNBOUNDED_ITERATION = "unbounded_iteration"
    CAPABILITY_LEAK = "capability_leak"
    MISSING_SIGNER = "missing_signer"
    EXCESSIVE_PRIVILEGES = "excessive_privileges"
    UNSAFE_RANDOMNESS = "unsafe_randomness"
    TIMESTAMP_DEPENDENCY = "timestamp_dependency"
    DENIAL_OF_SERVICE = "denial_of_service"
    LOGIC_ERROR = "logic_error"


@dataclass
class Vulnerability:
    """Represents a detected vulnerability."""
    vuln_type: VulnerabilityType
    severity: VulnerabilitySeverity
    title: str
    description: str
    location: Optional[str] = None
    recommendation: str = ""
    confidence: float = 0.8
    details: dict[str, Any] = field(default_factory=dict)


@dataclass
class VulnerabilityReport:
    """Complete vulnerability report for a module."""
    module_address: str
    module_name: str
    vulnerabilities: list[Vulnerability] = field(default_factory=list)
    scan_summary: dict[str, Any] = field(default_factory=dict)
    
    @property
    def critical_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL)
    
    @property
    def high_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH)
    
    @property
    def medium_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM)
    
    @property
    def low_count(self) -> int:
        return sum(1 for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.LOW)


class VulnerabilityDetector:
    """
    Pattern-based vulnerability detector for Move smart contracts.
    
    Analyzes module structure, function signatures, and access patterns
    to identify potential security issues.
    """
    
    def __init__(self):
        self._checks = [
            self._check_missing_signer,
            self._check_excessive_friends,
            self._check_public_entry_exposure,
            self._check_capability_patterns,
            self._check_unbounded_generics,
            self._check_resource_handling,
            self._check_coin_operations,
        ]
    
    def analyze_module(self, module: ModuleInfo) -> VulnerabilityReport:
        """
        Analyze a module for vulnerabilities.
        
        Args:
            module: Parsed module information
            
        Returns:
            VulnerabilityReport with findings
        """
        vulnerabilities = []
        
        for check in self._checks:
            findings = check(module)
            vulnerabilities.extend(findings)
        
        return VulnerabilityReport(
            module_address=module.address,
            module_name=module.name,
            vulnerabilities=vulnerabilities,
            scan_summary={
                "total_functions": len(module.functions),
                "entry_functions": sum(1 for f in module.functions if f.is_entry),
                "public_functions": sum(1 for f in module.functions if f.visibility == FunctionVisibility.PUBLIC),
                "friends_count": len(module.friends),
                "structs_count": len(module.structs),
                "checks_performed": len(self._checks)
            }
        )
    
    def _check_missing_signer(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for entry functions without signer verification."""
        vulns = []
        
        for func in module.functions:
            if func.is_entry:
                has_signer = any(
                    "signer" in param.lower() or "&signer" in param.lower()
                    for param in func.params
                )
                
                if not has_signer:
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.MISSING_SIGNER,
                        severity=VulnerabilitySeverity.HIGH,
                        title="Entry Function Without Signer Verification",
                        description=f"Function '{func.name}' is marked as entry but does not take a signer parameter. This may allow unauthorized callers to execute the function.",
                        location=f"{module.name}::{func.name}",
                        recommendation="Add a &signer parameter to verify caller authorization.",
                        confidence=0.9,
                        details={"function": func.name, "params": func.params}
                    ))
        
        return vulns
    
    def _check_excessive_friends(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for excessive friend declarations."""
        vulns = []
        
        if len(module.friends) > 5:
            vulns.append(Vulnerability(
                vuln_type=VulnerabilityType.EXCESSIVE_PRIVILEGES,
                severity=VulnerabilitySeverity.MEDIUM,
                title="Excessive Friend Module Declarations",
                description=f"Module has {len(module.friends)} friend declarations. Large numbers of friends expand the trust boundary and increase attack surface.",
                location=module.name,
                recommendation="Review friend declarations and minimize to only essential modules.",
                confidence=0.7,
                details={"friends": module.friends, "count": len(module.friends)}
            ))
        
        return vulns
    
    def _check_public_entry_exposure(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for potentially over-exposed public entry functions."""
        vulns = []
        
        entry_functions = [f for f in module.functions if f.is_entry]
        public_functions = [f for f in module.functions if f.visibility == FunctionVisibility.PUBLIC]
        
        # High ratio of entry+public functions may indicate over-exposure
        total_functions = len(module.functions)
        exposed = len(entry_functions) + len(public_functions)
        
        if total_functions > 3 and exposed / total_functions > 0.8:
            vulns.append(Vulnerability(
                vuln_type=VulnerabilityType.EXCESSIVE_PRIVILEGES,
                severity=VulnerabilitySeverity.LOW,
                title="High Externally-Accessible Function Ratio",
                description=f"{exposed}/{total_functions} functions are publicly accessible. Consider if all need to be exposed.",
                location=module.name,
                recommendation="Review function visibility and reduce external exposure where possible.",
                confidence=0.5,
                details={
                    "entry_functions": [f.name for f in entry_functions],
                    "public_functions": [f.name for f in public_functions],
                    "ratio": exposed / total_functions
                }
            ))
        
        return vulns
    
    def _check_capability_patterns(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for potential capability leak patterns."""
        vulns = []
        
        # Look for structs with "Cap", "Capability", "Admin" in name
        capability_structs = [
            s for s in module.structs
            if any(cap in s.name.lower() for cap in ["cap", "capability", "admin", "owner", "auth"])
        ]
        
        for cap_struct in capability_structs:
            # Check if it has 'store' ability (can be stored anywhere)
            if "store" in cap_struct.abilities:
                vulns.append(Vulnerability(
                    vuln_type=VulnerabilityType.CAPABILITY_LEAK,
                    severity=VulnerabilitySeverity.MEDIUM,
                    title="Capability Struct with Store Ability",
                    description=f"Struct '{cap_struct.name}' appears to be a capability and has 'store' ability. This could allow the capability to be transferred or leaked.",
                    location=f"{module.name}::{cap_struct.name}",
                    recommendation="Consider if 'store' ability is necessary for capability structs.",
                    confidence=0.6,
                    details={"struct": cap_struct.name, "abilities": cap_struct.abilities}
                ))
            
            # Check if it has 'copy' ability
            if "copy" in cap_struct.abilities:
                vulns.append(Vulnerability(
                    vuln_type=VulnerabilityType.CAPABILITY_LEAK,
                    severity=VulnerabilitySeverity.HIGH,
                    title="Capability Struct with Copy Ability",
                    description=f"Struct '{cap_struct.name}' appears to be a capability and has 'copy' ability. This allows the capability to be duplicated freely.",
                    location=f"{module.name}::{cap_struct.name}",
                    recommendation="Remove 'copy' ability from capability structs to ensure linear usage.",
                    confidence=0.8,
                    details={"struct": cap_struct.name, "abilities": cap_struct.abilities}
                ))
        
        return vulns
    
    def _check_unbounded_generics(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for potentially unsafe generic type usage."""
        vulns = []
        
        for func in module.functions:
            if func.generic_type_params:
                # Check if generics are constrained
                unconstrained = [
                    gp for gp in func.generic_type_params
                    if not gp.get("constraints")
                ]
                
                if unconstrained and func.is_entry:
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.LOGIC_ERROR,
                        severity=VulnerabilitySeverity.LOW,
                        title="Entry Function with Unconstrained Generic Types",
                        description=f"Function '{func.name}' is entry with unconstrained generic type parameters. Ensure type validation is performed.",
                        location=f"{module.name}::{func.name}",
                        recommendation="Add ability constraints to generic type parameters.",
                        confidence=0.4,
                        details={
                            "function": func.name,
                            "generics": func.generic_type_params
                        }
                    ))
        
        return vulns
    
    def _check_resource_handling(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for resource handling patterns."""
        vulns = []
        
        # Check for structs with 'key' but no 'drop'
        for struct in module.structs:
            if "key" in struct.abilities and "drop" not in struct.abilities:
                # This is actually good practice - just note it
                pass
            
            # Warn if struct has both 'key' and 'drop' (resources that can be silently discarded)
            if "key" in struct.abilities and "drop" in struct.abilities:
                vulns.append(Vulnerability(
                    vuln_type=VulnerabilityType.LOGIC_ERROR,
                    severity=VulnerabilitySeverity.INFO,
                    title="Key Struct with Drop Ability",
                    description=f"Struct '{struct.name}' has both 'key' and 'drop' abilities. Resources with 'drop' can be silently discarded.",
                    location=f"{module.name}::{struct.name}",
                    recommendation="Consider if 'drop' is appropriate for this global resource.",
                    confidence=0.3,
                    details={"struct": struct.name, "abilities": struct.abilities}
                ))
        
        return vulns
    
    def _check_coin_operations(self, module: ModuleInfo) -> list[Vulnerability]:
        """Check for potentially unsafe coin/token operations."""
        vulns = []
        
        # Look for functions dealing with coins
        coin_functions = []
        for func in module.functions:
            params_str = " ".join(func.params).lower()
            returns_str = " ".join(func.return_types).lower()
            
            if "coin" in params_str or "coin" in returns_str:
                coin_functions.append(func)
        
        for func in coin_functions:
            # Entry functions dealing with coins should have signer
            if func.is_entry:
                has_signer = any("signer" in p.lower() for p in func.params)
                if not has_signer:
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.ACCESS_CONTROL,
                        severity=VulnerabilitySeverity.CRITICAL,
                        title="Coin Operation Without Signer Verification",
                        description=f"Entry function '{func.name}' handles coins but lacks signer verification. This could allow unauthorized token operations.",
                        location=f"{module.name}::{func.name}",
                        recommendation="Add signer verification for all coin operations.",
                        confidence=0.95,
                        details={"function": func.name, "params": func.params}
                    ))
        
        return vulns


# Singleton instance
_detector: Optional[VulnerabilityDetector] = None


def get_vulnerability_detector() -> VulnerabilityDetector:
    """Get or create the vulnerability detector instance."""
    global _detector
    if _detector is None:
        _detector = VulnerabilityDetector()
    return _detector
